#include "def.h"
const int tetrinos[7][4][4][4] = { { {			{ 0, 0, 0, 0 },
												{ 1, 1, 1, 1 }, 
												{ 0, 0, 0, 0 }, 
												{ 0, 0, 0, 0 } }, 
										{
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 0, 0 } }, 
										{ 
												{ 0, 0, 0, 0 }, 
												{ 0, 0, 0, 0 }, 
												{ 1, 1, 1, 1 }, 
												{ 0, 0, 0, 0 } }, 
										{
												{ 0, 0, 1, 0 }, 
												{ 0, 0, 1, 0 }, 
												{ 0, 0, 1, 0 }, 
												{ 0, 0, 1, 0 } } }, 
										
										{ 
											{
												{ 0, 0, 0, 0 },
												{ 1, 1, 1, 0 },
												{ 0, 1, 0, 0 }, 
												{ 0, 0, 0, 0 } }, 
											{
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 1, 0 },
												{ 0, 1, 0, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 0, 0, 0 },
												{ 0, 1, 0, 0 },
												{ 1, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 1, 0, 0 }, 
												{ 1, 1, 0, 0 }, 
												{ 0, 1, 0, 0 }, 
												{ 0, 0, 0, 0 } } },
										{ 
											
											{
												{ 0, 0, 0, 0 },
												{ 1, 1, 1, 0 },
												{ 1, 0, 0, 0 }, 
												{ 0, 0, 0, 0 } }, 
											{
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 0, 0, 0 },
												{ 0, 0, 1, 0 },
												{ 1, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 1, 1, 0, 0 }, 
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 0, 0 }, 
												{ 0, 0, 0, 0 } } },
										{ 
												
											
											{
												{ 0, 0, 0, 0 },
												{ 1, 1, 1, 0 },
												{ 0, 0, 1, 0 }, 
												{ 0, 0, 0, 0 } }, 
											{
												{ 0, 1, 1, 0 }, 
												{ 0, 1, 0, 0 },
												{ 0, 1, 0, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 0, 0, 0 },
												{ 1, 0, 0, 0 },
												{ 1, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 0, 0 }, 
												{ 1, 1, 0, 0 }, 
												{ 0, 0, 0, 0 } } },
										{ 
											
											{
												{ 0, 0, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 1, 1, 0, 0 },
												{ 0, 0, 0, 0 } },
											{
												{ 1, 0, 0, 0 }, 
												{ 1, 1, 0, 0 },
												{ 0, 1, 0, 0 },
												{ 0, 0, 0, 0 } }, 
											{
												{ 0, 0, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 1, 1, 0, 0 },
												{ 0, 0, 0, 0 } },
													
											{ 
												{ 0, 1, 0, 0 }, 
												{ 0, 1, 1, 0 }, 
												{ 0, 0, 1, 0 }, 
												{ 0, 0, 0, 0 } } },
										{ 
											
											{
												{ 0, 0, 0, 0 },
												{ 1, 1, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{
												{ 0, 1, 0, 0 }, 
												{ 1, 1, 0, 0 },
												{ 1, 0, 0, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 0, 0, 0 },
												{ 1, 1, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 0, 1, 0 }, 
												{ 0, 1, 1, 0 }, 
												{ 0, 1, 0, 0 }, 
												{ 0, 0, 0, 0 } } },
										{ 
											{
												{ 0, 0, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{
												{ 0, 0, 0, 0 }, 
												{ 0, 1, 1, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 0, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 0, 0, 0 } }, 
											{ 
												{ 0, 0, 0, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 1, 1, 0 },
												{ 0, 0, 0, 0 } } } };
										 
											
void rotate_tet(tetri* tet){
	int i, j;
	tet->rotation = tet->rotation++;
	tet->rotation = tet->rotation % 4;
	for (i = 0; i<4; i++){
		for (j = 0; j<4; j++){
			tet->visual[i][j] = tetrinos[tet->shape][tet->rotation][i][j];
		}
	}
}

void randomBag(Game* play){
	int ran;
	int i = 0;
	int t[7] = { 0, 1, 2, 3, 4, 5, 6 };

	if (play->bag[0] == -1){
		while (i<7){
			ran = rand() % 7;
			if (t[ran] != -1){
				play->bag[i] = ran;
				t[ran] = -1;
				i++;
			}
		}
		
		i = 0;
		for (i = 0; i < 7; i++){
			t[i] = i;
		}
		i = 0;
		while (i<7){
			ran = rand() % 7;
			if (t[ran] != -1){
				play->bag[i + 7] = ran;
				t[ran] = -1;
				i++;
			}
		}
	}
	else{
		while (i < 7){
			ran = rand() % 7;
			if (t[ran] != -1){
				play->bag[i + play->bool*7] = ran;
				t[ran] = -1;
				i++;
			}
		}
	}
	play->bool = !(play->bool);
	return;
}

int is_collison(int *play_tab, tetri *tet){
	int i, j, hit = 0;
	for (i = 0; i<4; i++){
		for (j = 0; j<4; j++){
			if ((tet->visual[i][j] == 1)
				&& play_tab[(tet->x_pos) + j + ((tet->y_pos) + i)*GAME_SIZE_X]>0){
				hit = 1;
				break;
			}
		}
	}
	return hit;
}

int is_ground(int *play_tab, tetri *tet){
	int i, j, hit = 0;
	for (i = 0; i<4; i++){
		for (j = 0; j<4; j++){
			if ((tet->visual[i][j] == 1)
				&& tet->y_pos+i==GAME_SIZE_Y){
				hit = 1;
				break;
			}
		}
	}
	return hit;
}

int is_complete_line(int* play_tab, int *result_tab){
	int i, j, ln_full = 0, ln_num = 0;
	for (i = 0; i<GAME_SIZE_Y; i++){
		ln_full = 1;
		for (j = 0; j<GAME_SIZE_X; j++){
			if (play_tab[i*GAME_SIZE_X + j] == 0){
				ln_full = 0;
			}

		}
		if (ln_full == 1){
			result_tab[i] = 1;
			ln_num++;
		}
		else{
			result_tab[i] = 0;
		}
	}
	return ln_num;
}

int reached_top(int *play_tab){
	int i, j;
	for (i = 0; i<2; i++){
		for (j = 0; j<GAME_SIZE_X; j++){
			if (play_tab[i*GAME_SIZE_X+j]>0){
				return 1;
				
			}
		}
	}
	return 0;
}

void clear_line(int *play_tab, int ln_num){
	int x, y;
	for (y = ln_num - 1; y>0; y--){
		for (x = 0; x<GAME_SIZE_X; x++){
			play_tab[(y + 1)*GAME_SIZE_X + x] = play_tab[(y) *GAME_SIZE_X + x];
		}
	}
	for (x = 0; x<GAME_SIZE_X; x++){
		play_tab[x] = 0;
	}



}

tetri * make_tet(int shape, int posx, int posy){
	int i, j;
	tetri * tetrin = malloc(sizeof(tetri));
	if (tetrin){

		tetrin->x_pos = posx;
		tetrin->y_pos = posy;
		tetrin->shape = shape;
		tetrin->hold_possible = 1;
		tetrin->rotation = 0;
		for (i = 0; i < 4; i++){
			for (j = 0; j < 4; j++){
				tetrin->visual[i][j] = tetrinos[shape][0][i][j];
			}
		}

		return tetrin;
	}
	return NULL;
}

void print_tet(tetri *tet, int* tab){
	int i, j;
	for (i = 0; i < 4; i++){
		for (j = 0; j < 4; j++){
			if (tet->visual[i][j] > 0){
				tab[j + tet->x_pos + (i + tet->y_pos)*GAME_SIZE_X] = tet->shape+1;
			}
		}
	}
}

void initialiseTab(int* tab){
  int i, j;
  for (i = 0; i < GAME_SIZE_Y; i++){
    for (j = 0; j < GAME_SIZE_X; j++){
      tab[i * GAME_SIZE_X + j] = 0;
    }
  }
}

int  legalPosition(Game *play, int posx, int posy,int rot){
  tetri temp;
  for (int i = 0; i < 4; i++){
    for (int j = 0; j < 4; j++){
      temp.visual[i][j] = play->current->visual[i][j];
	}
  }
  temp.shape = play->current->shape;
  temp.rotation = play->current->rotation;
  if (rot){
	  rotate_tet(&temp);
  }
  for (int i = 0; i < 4; i++){
	  for (int j = 0; j < 4; j++){
		  if (temp.visual[i][j] == 1){
			  if ((posx + j < 0 || posx + j >= GAME_SIZE_X)){
				  return 0;
			  }
		  }
	  }
  }


  temp.x_pos = posx;
  temp.y_pos = posy;
  if (reached_top(play->tab))
    return 3;
  if (is_collison(play->tab, &temp) || is_ground(play->tab, &temp))
    return 2;
	
  return 1;
}
/*
void copyTet(tetri *first, tetri *second){//FIXME
  if((first != NULL) && (second != NULL)){
    int i,j;
    for(i=0; i<4;i++){
      for(j=0;j<4;j++){
	second->visual[i][j] = first->visual[i][j];
      }
    }
    second->shape = first->shape;
    second->rotation = first->rotation;
    second->x_pos = first->x_pos;
    second->y_pos = first->y_pos;
    second->hold_possible = first->hold_possible;
  }
}
*/
void nextTetri(Game *game){
  if(game!=NULL){
	  
	  free(game->current);
	  free(game->next);
	  game->turn++;
	  game->current = make_tet(game->bag[game->turn % 14], 0, 0);
	  game->next = make_tet(game->bag[(game->turn + 1) % 14], 0, 0);
	  game->current->x_pos = 2;

	  if (game->turn % 6 == 0){
		  randomBag(game);
	  }
  }
}

void levelUp(Game *game){
  if(game!=NULL){
    if(game->lineCleared >= (game->level)*5){
		game->lineCleared -= (game->level) * 5;
		game->level++;
		game->game_speed_base = (float)(game->game_speed_base*COEF_DIFFUCLTY);
		game->game_speed = game->game_speed_base;
    }
  }
}

void hold(Game *game){
  if(game!=NULL){
    if(game->current->hold_possible == 0){
      return;
    }
    if(game->hold == NULL){
		game->hold = make_tet(game->current->shape, 0, 0);
		nextTetri(game);
    }
    else{
		tetri* buff;
		buff=game->current ;
		game->current = game->hold;
		game->hold = make_tet(buff->shape, 0, 0);
		free(buff);
		game->hold->hold_possible = 0;
    }
  }
}

void initialiseGame(Game *current_play){
	current_play->level = 1;
	initialiseTab(current_play->tab);
	current_play->lineCleared = 0;
	current_play->game_speed = 80;
	current_play->game_speed_base = 100;
	current_play->score = 0;
	current_play->bool = 0;
	current_play->bag[0] = -1;
	current_play->hold = NULL;
	randomBag(current_play);
	current_play->current = make_tet(current_play->bag[0], 0, 0);
	current_play->next = make_tet(current_play->bag[1], 0, 0);
	current_play->turn = 0;
}